<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<link href='favicon.ico' rel="shortcut icon" type="image/x-icon">
		<link rel="stylesheet" type="text/css" href="index.css">
		<link href="https://fonts.googleapis.com/css2?family=Balsamiq+Sans&family=Cormorant:wght@500;600;700&family=Fira+Sans&family=Press+Start+2P&family=Raleway:wght@300&family=Roboto:wght@300;400&family=Ubuntu&family=Yanone+Kaffeesatz&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Balsamiq+Sans&family=Cormorant:wght@500;600;700&family=Fira+Sans&family=Montserrat+Alternates&family=Press+Start+2P&family=Raleway:wght@300&family=Roboto:wght@300;400&family=Rubik&family=Source+Sans+Pro&family=Ubuntu&family=Yanone+Kaffeesatz&display=swap" rel="stylesheet">
		<title>Системы виртуальной и дополненной реальности</title>
	</head>
	<body>
	<script src="script.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
 	<script type="text/javascript" src="script2.js"></script>
		<header>
			<div class="in-header">
				<div class="course_name">
					<img src="favicon.ico" width="30px">
					Системы виртуальной и дополненной реальности
				</div>
			</div>
		</header>
		<div style="height:30px; width:100%"></div>
		<div class="layout">
			<div class="menu">
				<div style="height:30px; width:100%"></div>
				<div class="menu-buttons">
					<form action="index.html">
						<button class="menu-button">
							<i class="arrow_right"></i>
							Главная
						</button>
					</form>
					<form action="chapter1.html">
						<button class="menu-button">
							<i class="arrow_right"></i>
							Раздел 1
						</button>
					</form>
					<form action="chapter2.html">
						<button class="menu-button">
							<i class="arrow_right"></i>
							Раздел 2
						</button>
					</form>
					<form action="chapter3.html">
						<button class="menu-button">
							<i class="arrow_right"></i>
							Раздел 3
						</button>
					</form>
					<form action="chapter4.html">
						<button class="active">
							<i class="arrow_down"></i>
							Раздел 4
							<div class="submenu">
								<br><a class="anchor" href="#termin">Разработка систем ВР</a>
								<br><a class="anchor" href="#3ddvizh">Обзор 3D движков</a>
								<br><a class="anchor" href="#compareuu">Сравнительный анализ UNITY 3D и UNREAL ENGINE</a>
								<br><a class="anchor" href="#unreal">Начало работы UNREAL ENGINE</a>
								<br><a class="anchor" href="#test4">Тест</a>
							</div>
						</button>
					</form>
					<form action="chapter5.html">
						<button class="menu-button">
							<i class="arrow_right"></i>
							Раздел 5
						</button>
					</form>
				</div>
				<div style="height:10px; width:100%"></div>
				<div class="tooltip" style="width:100%">
					<iframe
						allow="microphone;"
						width="100%"
						height="430"
						src="https://console.dialogflow.com/api-client/demo/embedded/301aff36-214e-4460-a00b-d7596944a187">
					</iframe>
					<span class="tooltiptext">Вы можете задать вопрос по темам глав</span>
				</div>
			</div>
			<div id="toTop">
				<svg class="arrow-top-5" viewBox="0 0 154 109">
					<symbol id="Arrow" viewBox="-73.9 -55.3 135.9 85.4">
						<g>
							<polygon points="-73.9,29.1 -6,-9.2 61.9,30.1 61.9,14.2 -6,-25.1 -73.9,14.2 "/>
						</g>
						<g>
							<polygon points="-73.9,-1 -6,-39.3 61.9,0 61.9,-16 -6,-55.3 -73.9,-16 "/>
						</g>
					</symbol>
					<use xlink:href="#Arrow" width="135.9" height="85.4" id="XMLID_1_" x="-73.9" y="-55.3" transform="matrix(1.007 0 0 -1.007 83.0005 42)" />
				</svg>
			</div>
			<div class="text1">
				<div class="in-text">

					<a name="termin"></a>
					<h2>РАЗРАБОТКА СИСТЕМ ВР</h2>
					<div id="id1">
						<p class="text">
						У большинства всех систем виртуальной реальности есть (во всяком случае, должны быть), следующие основные характеристики.:
						<dl>
							<dt>- Моделирование в реальном времени. Система виртуальной реальности должна выдавать пользователю в ответ на совершаемые действия картинку, звук, а также 
							комплекс осязательных и прочих ощущений (если таковые предусмотрены) моментально, без заметных задержек.</dt>
							<dt>- Реалистичная имитация окружающей пользователя обстановки. Для полного погружения пользователя в мир виртуальной реальности, система должна отображать 
							виртуальные объекты с высотой степенью реалистичности, чтобы они выглядели «как живые».</dt>
							<dt>- Поддержка одного или нескольких пользователей. Системы виртуальной реальности различают по числу одновременно работающих пользователей и делят на 
							индивидуальные и коллективные. Как правило, индивидуальные системы создаются на базе устройств отображения, с которыми может работать только один человек 
							(шлемы, очки и т. п.). Системы для коллективной работы создаются на базе средств отображения, доступных сразу нескольким пользователям. Пример 
							стереоскопический видеопроектор, формирующий объемное изображение на большом.</dt>
							<dt>- VR-система должна давать стереооскопическое изображение, обеспечивающее ощущение глубины пространства. Человек обладает бинокулярным зрением, то есть 
							воспринимает мир обоими глазами сразу. При этом изображения, наблюдаемые каждым глазом, немного отличаются друг от друга и по отдельности не обладают 
							объемностью, но наш мозг складывает две картинки в единое объемное изображение. Современные технологии генерации псевдо объемных картинок основаны 
							именно на этом эффекте, и созданы так называемые стереоскопические пары изображений, обеспечивающие иллюзию объема.</dt>
							<dt>- Интерактивность - возможность взаимодействия с виртуальным миром. В «виртуальной вселенной» пользователь должен быть исключительно активным наблюдателем. 
							Он должен иметь возможность взаимодействовать с виртуальным окружением, а оно в свою очередь будет опираться на действия пользователя. Это позволит 
							пользователю оглядываться вокруг и перемещаться в любых направлениях внутри виртуальной среды.</dt>
						</dl>
						</p>
					</div>

					<br>
					<a name="3ddvizh"></a>
					<h2>ОБЗОР 3D-ДВИЖКОВ, ОСНОВНЫЕ ПОНЯТИЯ, ВОЗМОЖНОСТИ, УСЛОВИЯ ИСПОЛЬЗОВАНИЯ</h2>
					<div id="id4">
						<h3>Бесплатные игровые движки для 2D/3D игр</h3>
						<p class="text">
						Создание любой серьезной игры начинается с выбора движка для нее. Вариантов много, от простых платформ для встраиваемых 2D-проектов и до фреймворков для тайтлов AAA-класса. Выбрать среди них однозначно лучший игровой движок для создания своего проекта невозможно. Каждый инструмент хорош в своей области. С каким SDK работать – определяют:
						</p>
						<dl>
							<dt>- платформа для работы (ОС);</dt>
							<dt>- графические требования, поддерживаемые API;</dt>
							<dt>- поддерживаемые языки программирования;</dt>
							<dt>- жанровая принадлежность разрабатываемой игры;</dt>
							<dt>- потребности прорисовки и импорта графических элементов;</dt>
							<dt>- тонкости лицензирования;</dt>
							<dt>- процесс освоения инструмента;</dt>
							<dt>- поддержка разработчика и сообщества.</dt>
						</dl>
						<p class="text">
						Чтобы выбрать игровой движок для 2D- или 3D-игры было проще, предлагаем подборку из нескольких хороших и бесплатных (полностью или условно) SDK для геймдева.
						</p>
						<h3>Unity</h3>
						<p class="text">
						Unity – это кроссплатформенный SDK для разработки игр с двухмерной и трехмерной графикой, распространяемый по условно бесплатной модели. Использовать его можно безвозмездно, но на разработчика накладываются ограничения (доход не более $100 тыс. в год). Движок умеет работать с API DirectX, OpenGL, для работы с физикой задействован PhysX. Скрипты пишутся на C#.
						</p>
						<p class="text">
						Unity обладает интуитивно-понятным интерфейсом и прост в освоении. Движок использует компонентно-ориентированный подход. Он поддерживает модульность при разработке игр и упрощает подключение объектов. На движке возможна разработка игр любого жанра с графикой любого уровня. Но хоть выбор стандартных предустановленных решений и велик, интеграция внешних библиотек затруднена.
						</p>
						<p style="text-align: center;"><img src="Unity.png" alt="" width="50%"></p>
						<p class="text"><b>Преимущества Unity</b></p>
						<p class="text">
						К достоинствам движка относятся:
						<dl>
							<dt>- кроссплатформенность (Windows, Linux, Mac OSX, Android, iOS, веб-приложения);</dt>
							<dt>- простое освоение;</dt>
							<dt>- упрощенный импорт графических, звуковых компонентов в различных форматах;</dt>
							<dt>- выбор графических API;</dt>
							<dt>- сообщество разработчиков;</dt>
							<dt>- поддержка.</dt>
						</dl>
						</p>
						<p class="text"><b>Недостатки Unity</b></p>
						<p class="text">
						В число минусов фреймворка входят:
						<dl>
							<dt>- сложность интеграции внешних библиотек;</dt>
							<dt>- оптимизация использования аппаратных ресурсов в 2D-проектах и разработках на WebGL;</dt>
							<dt>- ограничение коммерческой эксплуатации (бесплатная лицензия – только при доходе менее $100 тыс. в год).</dt>
						</dL>
						</p>
						<h3>Unreal Engine</h3>
						<p class="text">
						Unreal Engine – игровой движок компании Epic Games, ориентированный на ААА-проекты и проекты в 3D. Он условно бесплатен при некоммерческом применении, но если проект приносит больше $3 тыс. в квартал – разработчикам движка нужно платить авторские отчисления в размере 5% от выручки. Первое, о чем стоит упомянуть в обзоре UE, это, конечно, графический потенциал, включающий поддержку даже DirectX 12. Нельзя забывать о кроссплатформенности этого SDK: на нем можно создавать игры для ПК, консолей, смартфонов, планшетов.
						</p>
						<p class="text">
						Unreal дает разработчику большой набор простых в освоении и интуитивно понятных инструментов. C++ накладывает минимум ограничений во время написания скриптов, а система визуального программирования Blueprint облегчает прототипирование или написание скриптов руками новичков. Создавать элементы игры можно наглядно, перемещая объекты, без ручного ввода кода.
						</p>
						<p class="text">
						В фирменном магазине доступен ассортимент готовых шаблонных решений. Они подойдут разработчикам, заинтересованным в быстром завершении игрового проекта. Среди прочих особенностей SDK – регулярные обновления, крупное сообщество и поддержка разработчиков.
						</p>
						<p style="text-align: center;"><img src="Unreal Engine.jpg" alt="" width="50%"></p>
						<p class="text"><b>Плюсы Unreal Engine</b></p>
						<p class="text">
						К преимуществам UE относятся:
						<dl>
							<dt>- графический потенциал;</dt>
							<dt>- поддержка стационарных и мобильных платформ;</dt>
							<dt>- очень большое сообщество;</dt>
							<dt>- легкость освоения и количество обучающих видеоматериалов;</dt>
							<dt>- саппорт.</dt>
						</dl>
						</p>
						<p class="text"><b>Минусы Unreal Engine</b></p>
						<p class="text">
						Недостатки игрового движка:
						<dl>
							<dt>- отсутствие совместимости со старыми консолями в UE4;</dt>
							<dt>- заточенность под высокоуровневые 3D-игры, делающая инструмент избыточным для простых проектов в 2D.</dt>
						</dl>
						</p>
						<h3>CryEngine</h3>
						<p class="text">
						CryEngine – это кроссплатформенный игровой движок для проектов стационарных платформ (ПК, консолей). Он распространяется по бесплатной модели, с роялти при преодолении порога выручки $5 тыс., но предлагается оформление платной подписки для расширенной поддержки. В этом SDK упор сделан на визуальную составляющую, основная сфера его применения – производство игр с 3D, использующих современные API для графики.
						</p>
						<p class="text">
						В CryEngine встроен простой визуальный редактор игровых элементов, позволяющий увидеть, как объекты будут смотреться в готовой игре. Поддерживается простое редактирование графических элементов, импорт моделей из редакторов (Maya, 3DS Max). Скриптовая система построена на Lua, известном многим представителям геймдева по легендарным S.T.A.L.K.E.R. и WoW.
						</p>
						<p class="text">
						Для оптимизации аппаратных нагрузок предусмотрена техника Geometry Instancing. Дополнительно из достоинств CryEngine стоит выделить поддержку инструментов ИИ, проработанные графические эффекты, систему звукового сопровождения.
						</p>
						<p style="text-align: center;"><img src="CryEngine.jpg" alt="" width="50%"></p>
						<p class="text"><b>Плюсы CryEngine</b></p>
						<p class="text">
						Преимущества CryEngine:
						<dl>
							<dt>- кроссплатформенность;</dt>
							<dt>- проработанная графическая составляющая;</dt>
							<dt>- трехмерный конструктор SandBox для визуального редактирования игр;</dt>
							<dt>- поддержка физики и свежих графических и звуковых API;</dt>
							<dt>- масштабируемость и расширяемость.</dt>
						</dl>
						</p>
						<p class="text"><b>Минусы CryEngine</b></p>
						<p class="text">
						Главные недостатки CryEngine:
						<dl>
							<dt>- относительно высокий порог вхождения;</dt>
							<dt>- проблемы поддержки «бесплатных» пользователей;</dt>
							<dt>- меньшая распространенность, чем у Unity или UE;</dt>
							<dt>- заточенность под тяжелые проекты в 3D.</dt>
						</dl>
						</p>
						<h3>Corona</h3>
						<p class="text">
						Corona – игровой движок для двухмерных игр, позиционируемый его авторами как «самая продвинутая платформа для создания 2D-программ в мире». Это бесплатный фреймворк, заточенный под написание приложений для мобильных и стационарных платформ. Он использует широко известный язык Lua, отличающийся простотой освоения и универсализмом. Модульная конфигурация поддерживает подключение внешних API и расширений. В магазине доступно более двух сотен плагинов, отвечающих за эффекты, аналитику, мультимедиа, интеграцию рекламы и другие функции во время разработки ПО.
						</p>
						<p class="text">
						Встроенный симулятор поддерживает просмотр результатов труда разработчика и может тестировать примененные решения в режиме реального времени. Система Live Build обеспечивает тесты разрабатываемой программы без ручной установки, так как обновление выполняется автоматически.
						</p>
						<p style="text-align: center;"><img src="Corona.jpg" alt="" width="50%"></p>
						<p class="text"><b>Плюсы Corona</b></p>
						<p class="text">
						Преимущества игрового движка:
						<dl>
							<dt>- бесплатная модель распространения;</dt>
							<dt>- легкость для новичка;</dt>
							<dt>- кроссплатформенность;</dt>
							<dt>- удобство отладки и тестирования проектов;</dt>
							<dt>- масштабируемость и поддержка внешних расширений.</dt>
						</dl>
						</p>
						<p class="text"><b>Минусы Corona</b></p>
						<p class="text">
						К недостаткам фреймворка относятся:
						<dl>
							<dt>- облачная сборка проектов;</dt>
							<dt>- слабый бесплатный саппорт (но есть комьюнити).</dt>
						</dl>
						</p>
						<h3>libGDX</h3>
						<p class="text">
						libGDX – популярный в среде разработчиков мобильных программ кроссплатформенный фреймворк, использующий C++ и Java. Он полностью бесплатен и поддерживает популярные современные ОС. Это инструмент для продвинутых девелоперов, так как без развитых навыков программирования в нем никак. Зато он поддерживает работу с 2D и 3D, умеет работать с подключаемыми модулями и библиотеками.
						</p>
						<p class="text">
						SDK предлагает встроенную библиотеку элементов UI, которые можно использовать в составе своей программы. Проекты, созданные в libGDX, имеют модульную архитектуру, благодаря чему можно собирать игры на основе основного модуля ядра с подключением специфичных отдельных модулей для каждой платформы (Windows, Android, Linux и т.д.).
						</p>
						<p style="text-align: center;"><img src="libGDX.jpg" alt="" width="50%"></p>
						<p class="text"><b>Плюсы libGDX</b></p>
						<p class="text">
						Плюсы фреймворка – это:
						<dl>
							<dt>- бесплатность;</dt>
							<dt>- кроссплатформенность;</dt>
							<dt>- виджеты и библиотеки для разработки UI;</dt>
							<dt>- подключаемые внешние расширения и модули;</dt>
							<dt>- производительность.</dt>
						</dl>
						</p>
						<p class="text"><b>Минусы libGDX</b></p>
						<p class="text">
						Недостатки движка:
						<dl>
							<dt>- объемы ручного программирования;</dt>
							<dt>- слабые возможности работы с 3D.</dt>
						</dl>
						</p>
						<h3>Defold</h3>
						<p class="text">
						Defold – еще один бесплатный кроссплатформенный движок для игровых программ. Он имеет визуальный редактор, предназначенный для создания 2D-игр с использованием языка Lua. Фреймворк отличается простыми инструментами для управления GUI и GO, подчиняемым редактором, широкими возможностями по работе с анимацией. Поддерживается командная разработка, для этого предусмотрена система доступа к проекту разрешенных пользователей.
						</p>
						<p class="text">
						С точки зрения использования аппаратных ресурсов Defold отличается небольшими размерами создаваемых программ и высокой производительностью даже на слабых устройствах. У движка имеется развитое сообщество, которое оперативно поможет в разрешении вопросов и проблем.
						</p>
						<p style="text-align: center;"><img src="Defold.jpg" alt="" width="50%"></p>
						<p class="text"><b>Плюсы Defold</b></p>
						<p class="text">
						К преимуществам фреймворка относятся:
						<dl>
							<dt>- кроссплатформенность;</dt>
							<dt>- производительность;</dt>
							<dt>- полная бесплатность;</dt>
							<dt>- простота использования;</dt>
							<dt>- развитое сообщество.</dt>
						</dl>
						</p>
						<p class="text"><b>Минусы Defold</b></p>
						<p class="text">
						Недостатками SDK можно назвать:
						<dl>
							<dt>- своеобразный подход к организации объектов;</dt>
							<dt>- ограниченные возможности работы с 3D.</dt>
						</dl>
						</p>
						<h3>Construct 2</h3>
						<p class="text">
						Закрывает подборку бесплатных игровых движков очень условно бесплатный Construct 2. Даром можно воспользоваться только пробной версией SDK, имеющей ограничения по количеству событий и эффектов в создаваемом проекте. Полноценная персональная лицензия стоит $130, а коммерческая — $430. Но упомянуть его стоит. Ведь этот набор инструментов для разработки игр в 2D подойдет даже людям, не имеющим навыков в программировании.
						</p>
						<p class="text">
						Проекты, созданные с использованием Construct 2, работают на основе HTML5 и могут воспроизводиться практически на любой современной платформе. Сам редактор функционирует на C++, созданный код преобразуется в JS. Предусмотрена возможность ручной правки кода. Она пригодится для пользователей, разбирающихся в программировании. Благодаря этому можно как минимум ознакомиться с возможностями движка, чтобы решить, стоит ли использовать его в реализации своего коммерческого проекта или лучше искать альтернативу.
						</p>
						<p style="text-align: center;"><img src="Construct 2.jpg" alt="" width="50%"></p>
						<p class="text"><b>Плюсы Construct 2</b></p>
						<p class="text">
						Плюсы движка:
						<dl>
							<dt>- доступность даже для новичков без навыков программирования;</dt>
							<dt>- простота создания игр в 2D;</dt>
							<dt>- кроссплатформенность и максимальная совместимость с различными ОС;</dt>
							<dt>- интеграция приложений, созданных в Construct 2, в веб-сервисы.</dt>
						</dl>
						</p>
						<p class="text"><b>Минусы Construct 2</b></p>
						<dl>
							<dt>- сильно урезанная бесплатная версия.</dt>
						</dl>
						<br>
						<p class="text"><b>Заключение</b></p>
						<p class="text">
						В зависимости от того, какие требования выдвигает ТЗ проекта, и происходит выбор оптимального решения. Ведь для простенькой мобильной 2D-игрушки под Android выбор будет одним, а для масштабного продукта с реалистичной графикой, заточенного под консоли последнего поколения или ПК, – совсем другой. Поэтому однозначно решить, какой из представленных бесплатных игровых движков лучший, позволит только анализ требований к проекту, который вы разрабатываете, и собственных навыков.
						</p>
					</div>

					<br>
					<a name="compareuu"></a>
					<h2>СРАВНИТЕЛЬНЫЙ АНАЛИЗ UNITY 3D И UNREAL ENGINE</h2>
					<div id="id5">
						<p class="text">
						ВР-разработчики предпочитают использовать игровые движки, самые популярные из которых Unreal Engine и Unity. Не смотря на 
						определенную схожесть данных движков, они имеют фундаментальную разницу. Unreal Engine появился в 1998 году и был предназначен 
						для создания конкретных игр с использованием всех возможностей компьютера. Unity же был создан позже в 2005 как многофункциональный 
						движок для различных платформ.
						</p>
						<p class="text">
						Для того, чтобы что-то создать в Unreal Engine необходимо знать язык С++ и сам движок, для Unity же можно не знакомится с языком 
						программирования С#, но познакомится с движком, который позволит сделать что угодно без программирования.
						В Unity включены объекты, компоненты, базовые сценарии и моделей материалов, однако, для того, чтобы создать свою логику, 
						необходимо написать свой скрипт. Минус движка в том, что исходные коды закрыты, а также присутствуют некоторые проблемы с 
						масштабированием объектов на различных устройствах.
						</p>
						<p class="text">
						В Unreal Engine есть много специализированных вложенных редакторов, некоторые из которых сравнимы по функционалу с целыми программами. 
						Бесплатно можно получить полнофункциональный редактор. Движок устанавливается вместе с исходным кодом, что позволяет с легкостью 
						разобраться в системе и исправлять какие-либо проблемы. Минус Unreal Engine – отсутствие дополнительной информации о движке, языке 
						С++, различных макросах и функциях.
						</p>
						<p class="text">
						Требование интерактивности является опциональным: в некоторых VR-системах человек выступает только в роли наблюдателя, но и это 
						бывает весьма полезно и интересно. VR-системы даже иногда делят на интерактивные и не интерактивные. Работа с последними больше 
						напоминает просмотр стереоскопического видеофильма, так как пользователь не может повлиять на то, что происходит в виртуальном мире. 
						Конечно, возможности «погружения» у такой VR куда скромнее, чем у полностью интерактивной виртуальной среды, но при достаточно 
						больших экранах и качественных спецэффектах впечатление от таких демонстраций остается неизгладимым.
						</p>
						<p class="text">
						Основными сферами применения виртуальной реальности являются: развлечения (компьютерные игры), профессиональное обучение (тренажеры и 
						симуляторы для летчиков, космонавтов, спасателей, врачей, водителей крупных автомобилей), образование (образовательные системы для 
						детей) и конструирование (космические аппараты, машины, строительные объекты, виртуальные миры), моделирование ситуаций (отработка 
						штатных или аварийных ситуаций и катастроф, устранение последствий), путешествия (виртуальные туры и экскурсии).
						</p>
						<h3>Устройство системы виртуальной реальности</h3>
						<p class="text">
						Практически в любой системе виртуальной реальности можно найти следующие компоненты:
						<dl>
							<dt>- Математические модели различных объектов и их окружения. В памяти компьютера виртуальный мир во всем его многообразии существует в 
							виде программных объектов, свойствами и поведением которых управляет заложенная в программу виртуальной реальности математическая 
							модель. Это запрограммированный разработчиками набор формул и уравнений, воспроизводящих элементы реального мира и их поведение. 
							Чем полнее (а стало быть, и сложнее) математическая модель виртуальной вселенной, тем реалистичнее иллюзия присутствия. За высокую 
							реалистичность приходится расплачиваться высокими требованиями к ресурсам компьютера, в котором «живет» виртуальная вселенная;</dt><br>
							<dt>- Программный модуль, преобразующий рассчитанные согласно математической модели параметры в видеоданные и управляющие команды для 
							подсистемы отображения;</dt><br>
							<dt>- Подсистема отображения, создающая и демонстрирующая пользователю объемное изображение модели;</dt><br>
							<dt>- Подсистема обратной связи оператора (пользователя) с моделями объектов и виртуальной средой. Этот компонент «сообщает» математической 
							модели данные о действиях пользователя, необходимые для расчета ответных действий виртуальной среды. Подсистема обратной связи 
							необходима только для интерактивных систем виртуальной реальности;</dt>
						</dl>
						</p>
						<h3>Как работает виртуальная реальность</h3>
						<p class="text">
						Основа виртуальной реальности - создание иллюзии присутствия человека в виртуальной обстановке. Человек «уходит» в нее, 
						отождествляет себя с персонажем, «живет» в этой игре. Обеспечит ли данная система полное погружение человека в виртуальную среду, 
						во многом зависит также от системы отображения.
						</p>
						<p class="text">
						В то же время многие виды работы с трехмерными объектами могут и не требовать «погружения» человека в мир этого объекта. К примеру, 
						при конструировании деталей сложной конфигурации или моделировании игровых персонажей обычно достаточно возможности манипулирования 
						объемным изображением конструируемого объекта на экране монитор компьютера.
						</p>
						<p class="text">
						Иллюзия присутствия в виртуальном мире может быть значительно усилена за счет создания объемного стереоскопического изображения 
						этого мира. Системы виртуальной реальности создают стереоскопическое трехмерное изображение за счет разделения картинок, 
						предназначенных для левого и правого глаза. В результате, благодаря окулярности зрения у человек формируется ощущение объемности 
						окружающего пространства, он может определять взаимное расположение предметов и также оценивать расстояния до них.
						</p>
						<h3>Системы отображения</h3>
						<p class="text">
						Известны следующие основные типы систем отображения для создания трехмерной виртуальной среды.
						<dl>
							<dt>1. Настольные системы</dt>
							<dt>Используют стандартные ЭЛТ-мониторы и стереоскопические дисплеи. Пользователь не погружается в виртуальную реальность, а видит 
							виртуальный мир через «окно» дисплея.</dt><br>
							<dt>2. PowerWall</dt>
							<dt>Многодисплейная система, на которой можно получить детализированные изображения крупных виртуальных объектов в натуральную величину.</dt><br>
							<dt>3. Шлемы виртуальной реальности</dt>
							<dt>Могут обеспечить полное погружение зрителя в виртуальную среду. Разделение картинок правого и левого глаза в шлеме происходит с 
							помощью встроенных оптических систем. Для получения качественной картинки разрешение экранов должно быть достаточно высоким.</dt><br>
							<dt>4. Проекционные системы</dt>
							<dt>При определенных условиях дают эффект, очень близкий к полному погружению в виртуальную среду.</dt><br>
							<dt>5. VR-системы</dt>
							<dt>В них виртуальное окружение проецируется на 4 или 6 стен-экранов специально оборудованного помещения. Система дает наиболее полный 
							эффект присутствия в виртуальном мире, который может усиливаться звуковыми эффектами.</dt>
						</dl>
						</p>
					</div>

					<br>
					<a name="unreal"></a>
					<h2>НАЧАЛО РАБОТЫ В UNREAL ENGINE, УСТАНОВКА ПРОГРАММЫ, ЗНАКОМСТВО С ИНТЕРФЕЙСОМ</h2>
					<div id="id6">
						<p style="text-align: center;"><img src="4.1.jpg" alt="" width="50%"></p>
						
						<p class="text">
						Unreal Engine 4 — это набор инструментов для разработки игр, имеющий широкие возможности: от создания двухмерных игр на мобильные до AAA-проектов для консолей. Этот движок использовался при разработке таких игр, как ARK: Survival Evolved, Tekken 7 и Kingdom Hearts III.
						</p>
						<p class="text">
						Разработка в Unreal Engine 4 очень проста для начинающих. С помощью системы визуального создания скриптов Blueprints Visual Scripting можно создавать готовые игры, не написав ни строчки кода! В сочетании с удобным интерфейсом это позволяет быстро изготавливать рабочие прототипы.
						</p>
						<p class="text">
						В этой части туториала по Unreal Engine 4 мы ознакомимся с основными возможностями программы. Вот основные темы, которые будут в нём рассмотрены:
						<dl>
							<dt>- Установка движка</dt>
							<dt>- Импорт ассетов</dt>
							<dt>- Создание материалов</dt>
							<dt>- Использование Blueprints для создания объектов с простейшими функциями</dt>
						</dl>
						</p>
						<p class="text">
						Мы изучим все эти возможности на примере поворотного столика, на котором лежит банан.
						</p>
						<h3>Установка Unreal Engine 4</h3>
						<p class="text">
						Для установки Unreal Engine 4 используется Epic Games Launcher. Перейдите на сайт Unreal Engine и нажмите на кнопку Get Unreal в правом верхнем углу.
						</p>
						<p style="text-align: center;"><img src="4.2.png" alt="" width="10%"></p>
						<p class="text">
						Перед загрузкой программы запуска необходимо будет создать учётную запись. После её создания скачайте программу запуска, соответствующую вашей операционной системе.
						</p>
						<p style="text-align: center;"><img src="4.3.png" alt="" width="30%"></p>
						<p class="text">
						После скачивания и установки программы запуска откройте её. Появится следующее окно:
						</p>
						<p style="text-align: center;"><img src="4.4.png" alt="" width="30%"></p>
						<p class="text">
						Введите адрес электронной почты и пароль, использованный для скачивания программы загрузки и нажмите на Sign In. После выполнения входа откроется такое окно:
						</p>
						<p style="text-align: center;"><img src="4.5.jpg" alt="" width="50%"></p>
						<p class="text">
						Нажмите на Install Engine в левом верхнем углу. Программа запуска перейдёт к экрану, на котором можно будет выбрать устанавливаемые компоненты.
						</p>
						<p style="text-align: center;"><img src="4.6.png" alt="" width="40%"></p>
						<p class="text">
						Примечание: Epic Games постоянно обновляет Unreal Engine, поэтому ваша версия движка может слегка отличаться от представленной на скриншотах. Например, после написания первого черновика этого туториала версия уже обновилась до 4.14.3! Туториал подойдёт вам, если у вас есть версия не ниже 4.14.
						</p>
						<p class="text">
						По умолчанию выбраны Starter Content, Templates and Feature Packs и Engine Source. Лучше так всё и оставить. Они будут полезны по следующим причинам:
						<dl>
							<dt>- Starter Content: это коллекция ассетов (ресурсов), которые можно бесплатно использовать в собственных проектах. В том числе это модели и материалы. Их можно использовать как временные ресурсы или в уже готовой игре.
							</dt><dt>- Templates and Feature Packs: шаблоны (Templates) задают базовые возможности выбранного жанра игры. Например, при выборе шаблона Side Scroller будет создан проект с персонажем, простыми движениями и камерой на фиксированной плоскости.
							</dt><dt>- Engine Source: Unreal — это движок с открытым исходным кодом, то есть вносить в него изменения может кто угодно. Если вам понадобится добавить к редактору дополнительные кнопки, то это можно сделать, изменив исходный код.
						</dt></dl>
						</p>
						<p class="text">
						Под списком есть список возможных платформ. Если не планируете разрабатывать игру под конкретную платформу, то можете спокойно снять все флажки.
						</p>
						<p style="text-align: center;"><img src="4.7.png" alt="" width="40%"></p>
						<p class="text">
						Выбрав нужные компоненты, нажмите на Install. После завершения установки движок появится в библиотеке. Теперь настало время создать проект.
						</p>
						<p style="text-align: center;"><img src="4.8.png" alt="" width="50%"></p>
						<h3>Создание проекта</h3>
						<p class="text">
						Нажмите на одну из кнопок Launch, чтобы открыть браузер проектов (Project Browser). После его открытия нажмите на вкладку New Project.
						</p>
						<p style="text-align: center;"><img src="4.9.png" alt="" width="50%"></p>
						<p class="text">
						Нажмите на вкладку Blueprint. Здесь можно выбрать один из шаблонов. Однако, поскольку мы начинаем с нуля, то выберем шаблон Blank.
						</p>
						<p class="text">
						Ниже будут перечисленные дополнительные параметры.
						</p>
						<p style="text-align: center;"><img src="4.10.png" alt="" width="30%"></p>
						<p class="text">
						Вот, за что отвечает каждая опция:
						<dl>
							<dt>- Target Hardware: при выборе Mobile/Tablet будут отключены некоторые эффекты постобработки. Также можно будет использовать мышь для сенсорного ввода. Выберите здесь опцию Desktop/Console.
							</dt><dt>- Graphical Target: при выборе Scalable 3D or 2D будут отключены некоторые эффекты постобработки. Выберите здесь Maximum Quality.
							</dt><dt>- Starter Content: можно включить эту опцию, чтобы добавить базовый контент (Starter Content). Чтобы нам было проще, выберем No Starter Content.
						</dt></dl>
						</p>
						<p class="text">
						Кроме того, здесь есть раздел для выбора местоположения папки проекта и имени проекта.
						</p>
						<p style="text-align: center;"><img src="4.11.png" alt="" width="40%"></p>
						<p class="text">
						Сменить папку хранения проекта можно, нажав на многоточие в конце поля Folder.
						</p>
						<p class="text">
						Имя проекта не является названием игры, так что не волнуйтесь, если хотите название позже. Выберите текст в поле Name и введите BananaTurntable.
						</p>
						<p class="text">
						И наконец нажмите на Create Project.
						</p>
						<h3>Навигация по интерфейсу</h3>
						<p class="text">
						После создания проекта откроется редактор. Он разделён на несколько панелей:<br/>
						<p style="text-align: center;"><img src="4.12.jpg" alt="" width="50%"></p>
						<dl>
							<dt>- Content Browser: в этой панели отображаются все файлы проекта. Её можно использовать для создания папок и упорядочивания файлов. Здесь также можно выполнять поиск по файлам с помощью поисковой строки или фильтров.
							</dt><dt>- Modes: в этой панели можно переключаться между инструментами, например Landscape Tool и Foliage Tool. Инструментом по умолчанию является Place Tool. Он позволяет располагать на уровне различные типы объектов, такие как источники освещения и камеры.
							</dt><dt>- World Outliner: отображает все объекты на текущем уровне. Можно упорядочить список, распределив связанные объекты по папкам, а также искать и фильтровать их по типам.
							</dt><dt>- Details: здесь отображаются все свойства выбранного объекта. Эта панель используется для изменения параметров объекта. Внесённые изменения повлияют только на выбранный экземпляр объекта. Например, если в сцене есть две сферы, то при изменении размера одной изменения коснутся только неё.
							</dt><dt>- Toolbar: содержит множество различных функций. Чаще всего мы будем пользоваться Play.
							</dt><dt>- Viewport: это обзор уровня. Осматриваться по сторонам можно, удерживая правую клавишу мыши и перемещая её. Для перемещения по уровню нужно зажать right-click and use the WASD keys.
						</dt></dl>
						</p>
						<h3>Импорт ассетов</h3>
						<p class="text">
						Какой смысл в поворотном столе, если на нём нечего показывать? Скачайте эту модель банана. Внутри находятся два файла: Banana_Model.fbx и Banana_Texture.jpg. Можете также использовать собственную модель, но зачем, если есть такой потрясающий банан?
						</p>
						<p class="text">
						Чтобы Unreal мог использовать файлы, их нужно импортировать. Перейдите в Content Browser и нажмите на Import.
						</p>
						<p style="text-align: center;"><img src="4.13.png" alt="" width="40%"></p>
						<p class="text">
						С помощью диспетчера файлов найдите папку, в которой находятся Banana_Model.fbx и Banana_Texture.jpg are. Выделите оба файла и нажмите Open.
						</p>
						<p style="text-align: center;"><img src="4.14.png" alt="" width="50%"></p>
						<p class="text">
						Unreal предложит несколько вариантов импорта файла .fbx. Снимите флажок Import Materials, потому что мы будем создавать собственный материал. Остальные параметры можно не менять.
						</p>
						<p style="text-align: center;"><img src="4.15.png" alt="" width="40%"></p>
						<p class="text">
						Нажмите на Import. Два файла появятся в Content Browser.
						</p>
						<p style="text-align: center;"><img src="4.16.png" alt="" width="40%"></p>
						<p class="text">
						При импорте файла на самом деле он не сохраняется в проект, если не указать этого явным образом. Сохранять файлы можно, нажав на файл правой клавишей мыши и выбрав Save. Также можно сохранить все файлы за раз, выбрав File\Save All. Старайтесь сохраняться почаще!
						</p>
						<p class="text">
						Учтите, что в Unreal модели называются «мешами» (meshes). Теперь у нас есть меш банана, настало время добавить его на уровень.
						</p>
						<h3>Добавление мешей на уровень</h3>
						<p class="text">
						Пока уровень выглядит довольно пустым, давайте сделаем его интереснее.
						</p>
						<p class="text">
						Чтобы добавить на уровень меш, нажмите правой клавишу мыши и перетащите Banana_Model из Content Browser во Viewport. Отпустите левую клавишу мыши и меш добавится на уровень.
						</p>
						<p style="text-align: center;"><img src="4.17.gif" alt="" width="50%"></p>
						<p class="text">
						Объекты на уровне можно перемещать, поворачивать и масштабировать. Горячие клавиши для этих действий — W, E и R. После нажатия на них можно использовать манипулятор:
						</p>
						<p style="text-align: center;"><img src="4.18.gif" alt="" width="50%"></p>
						<h3>О материалах</h3>
						<p class="text">
						Если внимательно посмотреть на банан, то можно увидеть, что он не жёлтый! На самом деле. он выглядит почти полностью серым.
						</p>
						<p class="text">
						Чтобы придать банану цвет и детали, необходимо создать материал.
						</p>
						<p class="text">
						Что такое «материал»?
						<dl>
							<dt>- Материал задаёт внешний вид поверхности. На базовом уровне материал определяет четыре аспекта:
							</dt><dt>- Base Color: цвет или текстуру поверхности. Используется для добавления детализации и вариаций цвета.
							</dt><dt>- Metallic: насколько металлическим выглядит материал. В общем случае, чисто металлический объект имеет максимальное значение Metallic, а ткань — значение 0.
							</dt><dt>- Specular: управляет блеском неметаллических поверхностей. Например, керамика будет обладать высоким значением Specular, в отличие от глины.
							</dt><dt>- Roughness: поверхность с максимальной roughness (шероховатостью) не будет иметь никакого блеска. Используется для таких поверхностей, как камень и дерево.
						</dt></dl>
						</p>
						<p class="text">
						Ниже представлен пример трёх различных материалов. Они имеют одинаковый цвет, но разные атрибуты. Каждый материал имеет высокое значение соответствующего атрибута. Значение остальных атрибутов равно нулю.
						</p>
						<p style="text-align: center;"><img src="4.19.jpg" alt="" width="40%"></p>
						<h3>Создание материала</h3>
						<p class="text">
						Для создания материала нужно перейти в Content Browser и нажать на зелёную кнопку Add New. Появится меню со списком ассетов, которые можно создать. Выберите Material.
						</p>
						<p style="text-align: center;"><img src="4.20.png" alt="" width="20%"></p>
						<p class="text">
						Назовите материал Banana_Material, а затем дважды нажмите левой клавишей мыши на файле, чтобы открыть его в редакторе материалов.
						</p>
						<p style="text-align: center;"><img src="4.21.png" alt="" width="20%"></p>
						<h3>Редактор материалов (Material Editor)</h3>
						<p class="text">
						Редактор материалов состоит из пяти основных панелей:<br/>
						<p style="text-align: center;"><img src="4.22.png" alt="" width="50%"></p>
						<dl>
							<dt>- Graph: в этой панели содержатся все ноды (узлы) и нод Result. Перемещаться по панели можно, удерживая правую клавишу мыши и двигая мышью. Масштабирование выполняется прокруткой колёсика мыши.
							</dt><dt>- Details: здесь отображаются свойства выбранного нода. Если нод не выбран, то здесь отображаются свойства материала.
							</dt><dt>- Viewport: содержит меш предварительного просмотра, представляющий материал. Поворачивать камеру можно, удерживая левую клавишу и двигая мышь. Масштабирование выполняется прокруткой колёсика мыши.
							</dt><dt>- Palette: список всех нодов, доступных для вашего материала.
						</dt></dl>
						</p>
						<h3>Что такое нод (узел)?</h3>
						<p class="text">
						Прежде чем приступать к созданию своего материала, нужно узнать про объекты, которые используются для его создания: ноды.
						</p>
						<p class="text">	
						Ноды составляют бОльшую часть материала. Существует множество типов нодов, имеющих различные функции.
						</p>
						<p class="text">
						У нодов есть входы и выходы, представленные кругом со стрелкой. Входы расположены слева, а выходы — справа.
						</p>
						<p class="text">
						Вот пример с использованием нодов Multiply и Constant3Vector, добавляющих текстуре жёлтого цвета:
						</p>
						<p style="text-align: center;"><img src="4.23.png" alt="" width="30%"></p>
						<p class="text">
						У материалов есть особый нод, называемый нодом Result, который в нашем случае уже создан как Banana_Material. Здесь заканчиваются со временем все ноды. То, что подключено к этому ноду, определяет внешний вид конечного материала.
						</p>
						<p style="text-align: center;"><img src="4.224.png" alt="" width="15%"></p>
						<h3>Добавление текстур</h3>
						<p class="text">
						Для добавления модели цвета и деталей нам необходима текстура. Текстура — это просто двухмерное изображение. Обычно они проецируются на трёхмерные модели, придавая им цвет и детали.
						</p>
						<p class="text">
						Для текстурирования банана мы используем Banana_Texture.jpg. Применить в материале текстуру позволяет нод TextureSample.
						</p>
						<p class="text">
						Перейдите к панели Palette и найдите TextureSample. Добавьте нод, удерживая левую клавишу мыши и перетащив его на схему.
						</p>
						<p style="text-align: center;"><img src="4.24.gif" alt="" width="50%"></p>
						<p class="text">
						Для выбора текстуры необходимо сначала выделить нод TextureSample. Перейдите в панель Details и нажмите на раскрывающийся список, расположенный справа от Texture.
						</p>
						<p style="text-align: center;"><img src="4.25.png" alt="" width="30%"></p>
						<p class="text">
						Откроется меню, в котором перечислены все текстуры проекта. Выберите Banana_Texture.
						</p>
						<p style="text-align: center;"><img src="4.26.png" alt="" width="30%"></p>
						<p class="text">
						Чтобы увидеть текстуру на меше предварительного просмотра, нужно подключить её к ноду Result. Удерживайте левую клавишу мыши на белом контакте выхода нода TextureSample. Перетащите его на входной контакт Base Color нода Result.
						</p>
						<p style="text-align: center;"><img src="4.27.gif" alt="" width="40%"></p>
						<p class="text">
						Вернитесь во Viewport, чтобы увидеть текстуру на меше предварительного просмотра. Можно поворачивать его (удерживая левую клавишу мыши и перемещая мышь), чтобы рассмотреть другие детали.
						</p>
						<p style="text-align: center;"><img src="4.28.jpg" alt="" width="30%"></p>
						<p class="text">
						Нажмите на Apply в Toolbar, чтобы обновить материал, и закройте редактор материалов после завершения.
						</p>
						<h3>Использование материалов</h3>
						<p class="text">
						Чтобы применить материал на банан, нужно его назначить. Вернитесь к Content Browser и дважды нажмите на Banana_Model, чтобы открыть его. Появится следующее окно редактора:
						</p>
						<p style="text-align: center;"><img src="4.29.jpg" alt="" width="50%"></p>
						<p class="text">
						Перейдите в панель Details и найдите раздел Materials. Нажмите на раскрывающееся меню, расположенное справа от Element 0, и выберите Banana_Material.
						</p>
						<p style="text-align: center;"><img src="4.30.png" alt="" width="40%"></p>
						<p class="text">
						Закройте редактор мешей, вернитесь к основному редактору и посмотрите на Viewport. Вы увидите, что теперь на банане есть текстура. Поздравляю, вы теперь знаете всё необходимео, чтобы стать дизайнером уровней!
						</p>
						<p style="text-align: center;"><img src="4.31.jpg" alt="" width="40%"></p>
						<p class="text">
						Примечание: если освещение слишком тёмное, можно изменить его, зайдя в World Outliner и нажав на Light Source. В панели Details найдите параметр Intensity и увеличьте его значение.
						</p>
						<h3>Про Blueprints</h3>
						<p class="text">
						Даже несмотря на то, что банан выглядит отлично, будет ещё лучше, если он начнёт вращаться на поворотном столе. Проще всего создать его с помощью «чертежей» Blueprints.
						</p>
						<p class="text">
						В простейшем случае Blueprint представляет собой «вещь». Blueprints позволяют создавать свои поведения для объектов. Объект может быть чем-то физическим (типа поворотного стола) или чем-то абстрактным, например, системой здоровья.
						</p>
						<p class="text">
						Хотите создать движущийся автомобиль? Используйте Blueprint. А как насчёт летающей свинки? Используйте Blueprints. А если нужен взрывающийся при касании котик? Blueprints.
						</p>
						<p class="text">
						Как и в материалах, в Blueprints используется система на основе нодов. Это значит, что достаточно создать ноды и соединить их — никакого кода не требуется!
						</p>
						<p class="text">
						Примечание: если вы предпочитаете писать код, то используйте вместо этого C++.
						</p>
						<p class="text">
						Blueprints просты в использовании, однако не так быстры, как код на C++. То есть если вам нужно создать что-то «тяжёлое» с точки зрения вычислений, например, сложный алгоритм, то лучше воспользоваться C++.
						</p>
						<p class="text">
						Но даже если вы предпочитаете C++, то бывают случаи, когда оптимальнее использовать Blueprints. Вот некоторые из преимуществ Blueprints:
						<dl>
							<dt>- Обычно разработка на Blueprints быстрее, чем на C++.
							</dt><dt>- Простота упорядочивания. Можно разделять ноды на разные области, например, на функции и графы.
							</dt><dt>- Если вы работаете с людьми, не знающими программирование, то изменение Blueprint проще благодаря их наглядности и интуитивной понятности.
						</dt></dl>
						</p>
						<p class="text">
						Хорошим подходом будет создание объектов с помощью Blueprints. А когда требуются дополнительные возможности, преобразование их в C++.
						</p>
						<h3>Создание Blueprint</h3>
						<p class="text">
						Перейдите в Content Browser и нажмите на Add New. Выберите в списке Blueprint Class.
						</p>
						<p style="text-align: center;"><img src="4.32.png" alt="" width="20%"></p>
						<p class="text">
						Откроется окно с запросом выбора родительского класса. Ваш Blueprint будет наследовать все переменные, функции и компоненты из выбранного родительского класса. Уделите время на изучение возможностей каждого класса.
						</p>
						<p style="text-align: center;"><img src="4.33.png" alt="" width="40%"></p>
						<p class="text">
						Примечание: поскольку мы можем расположить классы Pawn и Character, они также являются акторами (Actors).
						</p>
						<p class="text">
						Поворотный стол будет находиться на месте, поэтому самым подходящим будет класс Actor. Выберите Actor и назовите новый файл Banana_Blueprint.
						</p>
						<p style="text-align: center;"><img src="4.34.png" alt="" width="30%"></p>
						<p class="text">
						Дважды нажмите на Banana_Blueprint, чтобы открыть его. Нажмите на Open Full Blueprint Editor, если появится подобное окно:
						</p>
						<p style="text-align: center;"><img src="4.35.png" alt="" width="50%"></p>
						<h3>Blueprint Editor</h3>
						<p class="text">
						Во-первых, выберите в редакторе Blueprint editor вкладку Event Graph.
						</p>
						<p class="text">
						Blueprint editor состоит из четырёх основных панелей:<br/>
						<p style="text-align: center;"><img src="4.36.png" alt="" width="50%"></p>
						<dl>
							<dt>- Components: содержит список текущих компонентов.</dt>
							<dt>- My Blueprint: этот раздел обычно используется для управления графами, функциями и переменными.</dt>
							<dt>- Details: здесь отображаются свойства текущего выбранного элемента.</dt>
							<dt>- Graph: именно здесь происходит магия. Все ноды и логика находятся здесь. Перемещаться по панели можно, зажав правую клавишу мыши и перемещая мышь. Масштабирование выполняется прокруткой колёсика мыши.</dt>
							<dt>- Viewport: здесь отображаются все компоненты, имеющие визуальные элементы. Перемещение и обзор выполняются так же, как и во Viewport основного редактора.</dt>
						</dl>
						</p>
						<h3>Создание поворотного стола</h3>
						<p class="text">
						Для создания стола нам нужно две вещи — основание и подставка. Их можно создать с помощью компонентов.
						</p>
						<h3>Что такое «компоненты»?</h3>
						<p class="text">
						Если Blueprint — это автомобиль, то компоненты — это строительные элементы, из которых он состоит. Примерами компонентов могут быть двери, колёса и двигатель.
						</p>
						<p class="text">
						Однако компоненты могут быть не только физическими объектами.
						</p>
						<p class="text">
						Например, чтобы автомобиль мог двигаться, можно добавить компонент движения. Можно даже заставить машину летать, если добавить компонент полёта.
						</p>
						<h3>Добавление компонентов</h3>
						<p class="text">
						Чтобы увидеть компоненты, необходимо переключиться в режим Viewport. Нажмите на вкладку Viewport, чтобы переключиться на неё. Вот как это выглядит:
						</p>
						<p style="text-align: center;"><img src="4.37.jpg" alt="" width="50%"></p>
						<p class="text">
						Примечание: компонент DefaultSceneRoot при запуске приложения не отображается, он виден только в редакторе.
						</p>
						<p class="text">
						Поворотный стол будет использовать два компонента:
						<dl>
							<dt>- Cylinder: простой белый цилиндр. Это будет основанием, на котором лежит банан.</dt>
							<dt>- Static Mesh: — это компонент будет отображать меш банана.</dt>
						</dl>
						</p>
						<p class="text">
						Чтобы добавить основание, перейдите в панель Components. Нажмите на Add Component и выберите Cylinder.
						</p>
						<p style="text-align: center;"><img src="4.38.png" alt="" width="30%"></p>
						<p class="text">
						Неплохо было бы сделать основание чуть короче. Активируйте манипулятор масштаба, нажав R, а затем уменьшите масштаб (точный размер неважен, можно будет изменить его позже).
						</p>
						<p style="text-align: center;"><img src="4.39.gif" alt="" width="40%"></p>
						<p class="text">
						Теперь пора добавить меш. Вернитесь в панель компонентов Components и нажмите левой клавишей на пустой области, чтобы снять выделение с компонента Cylinder. Благодаря этому следующий добавляемый компонент не будет прикреплён к компонентуCylinder.
						</p>
						<p style="text-align: center;"><img src="4.40.gif" alt="" width="40%"></p>
						<p class="text">
						Примечание: если этого не сделать, то следующий компонент будет прикреплён к компоненту Cylinder. Это значит, что он также унаследует масштаб компонента Cylinder. Поскольку мы уменьшили масштаб цилиндра, следующий компонент тоже будет уменьшен.
						</p>
						<p style="text-align: center;"><img src="4.41.jpg" alt="" width="40%"></p>
						<p class="text">
						Затем нажмите на Add Component и выберите из списка Static Mesh.
						</p>
						<p style="text-align: center;"><img src="4.42.png" alt="" width="30%"></p>
						<p class="text">
						Для отображения банана выберите компонент Static Mesh, а затем нажмите на вкладку Details. Нажмите на раскрывающий списков в правой части Static Mesh и выберите Banana_Model.
						</p>
						<p style="text-align: center;"><img src="4.43.png" alt="" width="40%"></p>
						<p class="text">
						Переместите банан, если он находится в неправильном положении. Для этого активируйте манипулятор перемещения, нажав W, а затем переместите его вверх.
						</p>
						<p style="text-align: center;"><img src="4.44.gif" alt="" width="40%"></p>
						<h3>Про ноды Blueprint</h3>
						<p class="text">
						Теперь нужно сделать так, чтобы поворотный стол вращался. И здесь нам потребуются ноды Blueprint.
						</p>
						<p class="text">
						В отличие от своих близких родственников — нодов материалов — ноды Blueprint имеют особые контакты, называемые контактами Execution. Контакт слева — это вход, контакт справа — выход. У всех нодов есть хотя бы по одному входу и выходу.
						</p>
						<p class="text">
						Если нод имеет контакт входа, то его нужно подключить, чтобы он заработал. Если нод не поключен, все последующие ноды не будут выполняться.
						</p>
						<p class="text">
						Вот пример:
						</p>
						<p style="text-align: center;"><img src="4.45.png" alt="" width="40%"></p>
						<p class="text">
						Node A и Node B будут выполняться, потому что у их входных контактов есть подключение. Node C и Node D никогда не выполняются, потому что входной контакт Node C не имеет подключения.
						</p>
						<h3>Вращение поворотного стола</h3>
						<p class="text">
						Прежде чем начать, давайте посмотрим на панель Components. Можно заметить, что у Cylinder и Static Mesh есть отступ, а у DefaultSceneRoot — нет, потому что они подключены к DefaultSceneRoot.
						</p>
						<p style="text-align: center;"><img src="4.46.png" alt="" width="20%"></p>
						<p class="text">
						Если переместить, повернуть или отмасштабировать корневой компонент, то тоже самое произойдёт и с прикреплёнными к нему компонентами. Благодаря этому поведению можно поворачивать Cylinder и Static Mesh одновременно, а не по отдельности.
						</p>
						<h3>Создание нода</h3>
						<p class="text">
						Чтобы приступить к созданию скриптов, переключитесь назад на вкладку Event Graph.
						</p>
						<p class="text">
						Реализация вращения объекта настолько проста, что требует всего одного нода. Нажмите правой клавишей на пустое пространство в графе, чтобы открыть меню доступных нодов. Найдите AddLocalRotation. Нам нужно поворачивать основание и банан, поэтому мы просто будем вращать корневой компонент. Выберите AddLocalRotation (DefaultSceneRoot).
						</p>
						<p class="text">
						Примечание: если нода нет в списке, снимите флажок Context Sensitive в правом верхней части меню.
						</p>
						<p style="text-align: center;"><img src="4.47.png" alt="" width="40%"></p>
						<p class="text">
						В вашем графе теперь появится новый нод AddLocalRotation. Вход Target автоматически подключится к выбранному компоненту.
						</p>
						<p class="text">
						Чтобы задать значение вращения, перейдите к входу Delta Rotation и измените значение Z на 1.0. Благодаря этому Blueprint сможет выполнять вращение относительно оси Z. Чем выше значения, тем быстрее будет вращаться стол.
						</p>
						<p style="text-align: center;"><img src="4.48.png" alt="" width="40%"></p>
						<p class="text">
						Чтобы поворотный стол вращался постоянно, нужно вызывать AddLocalRotation в каждом кадре. Для выполнения нода в каждом кадре воспользуемся нодом Event Tick. Он уже находится в графе. Если его нет, то создайте его тем же способом, что и ранее.
						</p>
						<p class="text">
						Перетащите выходной контакт нода Event Tick ко входному контакту нода AddLocalRotation.
						</p>
						<p style="text-align: center;"><img src="4.49.gif" alt="" width="40%"></p>
						<p class="text">
						Примечание: в этой реализации скорость вращения зависит от частоты кадров. Это значит, что поворотный стол на медленных компьютерах будет вращаться с меньшей скоростью, и наоборот. Для туториала это нас вполне устраивает, потому что я не хочу ничего усложнять, но в будущем я покажу, как это исправить.
						</p>
						<p class="text">
						Наконец, перейдите в Toolbar и нажмите на Compile, чтобы обновить Blueprint, а затем закройте Blueprint editor.
						</p>
						<p style="text-align: center;"><img src="4.50.png" alt="" width="40%"></p>
						<h3>Добавление Blueprints на уровень</h3>
						<p class="text">
						Прежде чем добавлять Blueprint, вернитесь ко Viewport в основном редакторе и удалите модель банана. Для этого выберите модель, а затем выберите Edit\Delete или нажмите клавишу Delete.
						</p>
						<p class="text">
						Добавление Blueprint — это тот же процесс, что и добавление меша. Удерживайте левую клавишу мыши на файле и перетащите его во Viewport.
						</p>
						<p class="text">
						Перейдите к Toolbar и нажмите Play, чтобы увидеть результаты своих трудов!
						</p>
						<p style="text-align: center;"><img src="4.51.gif" alt="" width="50%"></p>
						<p class="text">
						Примечание: если вы не удалите исходную модель банана, то можете получить предупреждение о необходимости перестройки освещения. Если удалить модель, то ошибка больше не будет проявляться.
						</p>
					</div>
					<br><br><br>
				</div>

				<a name="test4"></a>
				<div style="width:100%; height:800px; margin-right:-50%; text-align:center;">
					<iframe src="https://docs.google.com/forms/d/e/1FAIpQLSeMSY-zTgfRsXT-ZL6vVaAj1YNk05OSK0eYg8XgupCT3TY-HA/viewform?embedded=true" 
					width="60%" height="100%" frameborder="0" marginheight="0" marginwidth="0">Загрузка…</iframe>
				</div>
				<br><br><br>
			</div>
			<br>
			<br>
			<br>
		</div>
	</body>
</html>